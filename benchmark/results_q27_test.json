{
  "vector": [
    {
      "id": 27,
      "question": "Перечисли все семь архитектурных решений, описанных в дизайне Semantic Companion Layer",
      "type": "global",
      "answer": "1. **Stable, Typed Northbound Contract**: The Semantic Companion Layer (SCL) provides a stable, typed interface for applications and agents, ensuring consistent interaction while abstracting backend complexities.\n\n2. **GraphQL Interface**: Chosen as the primary interface for its ability to provide a stable, typed contract that supports composable, nested domain shapes without exposing backend complexities.\n\n3. **Bounded Semantics**: Implemented through allowlists and packs, ensuring that semantics are governed and consistent, preventing arbitrary predicate requests.\n\n4. **Portable Semantic Outputs**: The system returns governed semantic outputs, such as constraints and provenance, instead of raw query strings, ensuring tool-ready and consistent data for downstream integration.\n\n5. **Governance by Construction**: Ensures structural validity by preventing arbitrary predicate requests and maintaining a consistent semantic contract.\n\n6. **Semantic Core Pipeline**: Manages the processing of intents through stages like linking, normalization, inference, compilation, and explainability, ensuring a structured transformation of unstructured intent.\n\n7. **Southbound Execution Adapters**: These adapters connect to various backend engines like SPARQL, Cypher, and vector search, allowing for interchangeable execution while keeping the engines as internal details.\n\n8. **Packs for Domain Semantics**: Allow domain semantics to evolve through data and configuration changes rather than API changes, ensuring flexibility and adaptability.\n\n9. **Strawberry Framework**: Ensures the integrity and verifiability of the GraphQL schema by using code-first types and generating SDL, maintaining the honesty of the contract.\n\n10. **Multi-Backend Strategy**: Utilizes the best engine for specific tasks (e.g., RDF/SPARQL for semantics, Cypher for traversals, vector search for linking) while maintaining a single GraphQL facade to simplify client interactions.\n\n11. **ConstraintSet**: A structured and portable semantic output that includes resolved product types, normalized properties, and linked entities, demonstrating the system's ability to deliver consistent and tool-ready artifacts.\n\n12. **Modular Framework**: Supports multiple domains through a `DomainConfig` class, allowing seamless switching between domains like finance and medicine, and enabling the addition of new domain modules without altering the core.\n\n13. **Agentic AI Integration**: Adapts to the 'plan/act/reflect' paradigm of agentic AI, requiring multi-step tool calls, explainability, and composability to manage complexity and partial context.",
      "confidence": 0.4269310938856005,
      "retries": 0,
      "latency": 6.795,
      "passed": true
    }
  ],
  "cypher": [
    {
      "id": 27,
      "question": "Перечисли все семь архитектурных решений, описанных в дизайне Semantic Companion Layer",
      "type": "global",
      "answer": "1. **Stable, Typed Northbound Contract**: The Semantic Companion Layer (SCL) provides a stable, typed interface for applications and agents, ensuring consistent interaction while abstracting backend complexities.\n\n2. **GraphQL Interface**: GraphQL is chosen as the primary interface for the northbound contract due to its ability to support composable, nested domain shapes without exposing backend complexities.\n\n3. **Bounded Semantics**: The SCL uses allowlists and packs to provide bounded semantics, ensuring that only governed semantic outputs are returned, not raw query strings.\n\n4. **Portable Semantic Outputs**: The architecture emphasizes returning portable semantic outputs, such as a \"ConstraintSet,\" which can be compiled into downstream tools, ensuring consistency and tool-readiness.\n\n5. **Governance by Construction**: The system is designed to ensure structural validity and governance, preventing arbitrary predicates and ensuring that semantics are governed and consistent.\n\n6. **Separation of Concerns**: The architecture separates the stable northbound interface, the semantic core pipeline, and the southbound execution adapters, allowing backend engines to remain interchangeable implementation details.\n\n7. **Multi-Backend Strategy**: The architecture employs a multi-backend strategy, using the best engine for specific tasks (e.g., RDF/SPARQL for semantics, Cypher for traversals, vector search for linking) while maintaining a single GraphQL facade to simplify client interactions.",
      "confidence": 0.4269310938856005,
      "retries": 0,
      "latency": 4.163,
      "passed": true
    }
  ],
  "hybrid": [
    {
      "id": 27,
      "question": "Перечисли все семь архитектурных решений, описанных в дизайне Semantic Companion Layer",
      "type": "global",
      "answer": "1. **Stable, Typed Northbound Contract**: The Semantic Companion Layer (SCL) provides a stable, typed interface for applications and agents, ensuring consistent interaction while abstracting backend complexities.\n\n2. **GraphQL Interface**: Chosen as the primary interface for the northbound contract due to its ability to support composable, nested domain shapes without exposing backend complexities.\n\n3. **Bounded Semantics**: Implemented through allowlists and packs, ensuring that semantics are governed and consistent, preventing arbitrary predicate requests.\n\n4. **Portable Semantic Outputs**: The system returns governed semantic outputs, such as constraints and provenance, instead of raw query strings, ensuring tool-ready and consistent data for downstream integration.\n\n5. **Governance by Construction**: Ensures structural validity by preventing arbitrary predicate requests, maintaining a consistent and governed semantic layer.\n\n6. **Semantic Core Pipeline**: Manages the processing of intents through stages like linking, normalization, inference, and compilation, ensuring explainability and debuggability.\n\n7. **Southbound Execution Adapters**: These adapters handle execution with various backend engines like SPARQL, Cypher, and vector search, keeping them as internal details while maintaining a consistent contract.",
      "confidence": 0.4269310938856005,
      "retries": 0,
      "latency": 3.764,
      "passed": true
    }
  ],
  "agent_pattern": [
    {
      "id": 27,
      "question": "Перечисли все семь архитектурных решений, описанных в дизайне Semantic Companion Layer",
      "type": "global",
      "answer": "1. **Stable, Typed Northbound Contract**: The Semantic Companion Layer (SCL) provides a stable, typed interface for applications and agents, ensuring consistent interaction while abstracting backend complexities.\n\n2. **GraphQL Interface**: Chosen as the primary interface for the northbound contract due to its ability to support composable, nested domain shapes without exposing backend complexities.\n\n3. **Bounded Semantics via Allowlists and Packs**: The SCL uses allowlists and packs to define domain semantics, ensuring that semantics are governed and evolve as data/configuration rather than API changes.\n\n4. **Portable Semantic Outputs**: The SCL returns governed semantic outputs, such as constraints and provenance, instead of raw query strings, ensuring portability and integration with downstream tools.\n\n5. **Governance by Construction**: The architecture ensures that semantics are governed structurally, preventing arbitrary predicate requests and maintaining validity.\n\n6. **Semantic Core Pipeline**: This component processes intents through stages like linking, normalization, inference, compilation, and explainability, transforming unstructured intent into structured semantic outputs.\n\n7. **Southbound Execution Adapters**: These adapters connect to various backend engines like SPARQL, Cypher, and vector search, keeping them as interchangeable implementation details while maintaining a stable contract for clients.",
      "confidence": 0.45632144248903755,
      "retries": 0,
      "latency": 5.508,
      "passed": true
    }
  ],
  "agent_llm": [
    {
      "id": 27,
      "question": "Перечисли все семь архитектурных решений, описанных в дизайне Semantic Companion Layer",
      "type": "global",
      "answer": "1. **Stable, Typed Northbound Contract**: The Semantic Companion Layer (SCL) provides a stable, typed interface for applications and agents, ensuring consistent interaction while abstracting backend complexities.\n\n2. **GraphQL Interface**: Chosen as the primary interface for the northbound contract due to its ability to support composable, nested domain shapes without exposing backend complexities.\n\n3. **Bounded Semantics via Allowlists and Packs**: The SCL uses allowlists and packs to define domain semantics, ensuring that semantics are governed and evolve as data/configuration rather than through API changes.\n\n4. **Portable Semantic Outputs**: The SCL returns governed semantic outputs, such as constraints and provenance, instead of raw query strings, ensuring portability and integration with downstream tools.\n\n5. **Governance by Construction**: The architecture ensures structural validity by governing semantics through design, preventing arbitrary predicate requests from agents.\n\n6. **Semantic Core Pipeline**: This layer processes intents through stages like linking, normalization, inference, compilation, and explainability, transforming unstructured intent into structured semantic outputs.\n\n7. **Southbound Execution Adapters**: These adapters connect to various backend tools like SPARQL, Cypher, and vector search, keeping execution engines as interchangeable internal details while maintaining a stable contract for clients.",
      "confidence": 0.45632144248903755,
      "retries": 0,
      "latency": 6.038,
      "passed": true
    }
  ],
  "agent_mangle": [
    {
      "id": 27,
      "question": "Перечисли все семь архитектурных решений, описанных в дизайне Semantic Companion Layer",
      "type": "global",
      "answer": "1. **Stable, Typed Northbound Contract**: The Semantic Companion Layer (SCL) provides a stable, typed interface for applications and agents, ensuring consistent interaction while abstracting backend complexities.\n\n2. **GraphQL Interface**: Chosen as the primary interface for the northbound contract due to its ability to support composable, nested domain shapes without exposing backend complexities.\n\n3. **Bounded Semantics via Allowlists and Packs**: The SCL uses allowlists and packs to define domain semantics, ensuring that semantics are governed and evolve as data/configuration rather than API changes.\n\n4. **Portable Semantic Outputs**: The SCL returns governed semantic outputs, such as constraints and provenance, instead of raw query strings, ensuring portability and integration with downstream tools.\n\n5. **Governance by Construction**: The architecture ensures structural validity by governing semantics through design, preventing arbitrary predicate requests from agents.\n\n6. **Semantic Core Pipeline**: This component processes intents through stages like linking, normalization, inference, compilation, and explainability, forming the behavioral core of the SCL.\n\n7. **Southbound Execution Adapters**: These adapters connect to various backend engines like SPARQL, Cypher, and vector search, treating them as interchangeable implementation details to maintain a stable contract.",
      "confidence": 0.45632144248903755,
      "retries": 0,
      "latency": 5.942,
      "passed": true
    }
  ]
}